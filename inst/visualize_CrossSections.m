## Copyright (C) 2018-2023 Andreas Bertsatos <abertsatos@biol.uoa.gr>
##
## This program is free software; you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free Software
## Foundation; either version 3 of the License, or (at your option) any later
## version.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
## details.
##
## You should have received a copy of the GNU General Public License along with
## this program; if not, see <http://www.gnu.org/licenses/>.

## -*- texinfo -*-
## @deftypefn  {csg-toolkit} {} visualize_CrossSections (@var{bone_id})
## @deftypefnx {csg-toolkit} {} visualize_CrossSections (@var{bone_id}, @var{mode})
## @deftypefnx {csg-toolkit} {@var{CS_Geometry} =} visualize_CrossSections (@var{bone_id})
## @deftypefnx {csg-toolkit} {@var{CS_Geometry} =} visualize_CrossSections (@var{bone_id}, @var{mode})
## @deftypefnx {csg-toolkit} {[@var{CS_Geometry}, @var{SMoA}] =} visualize_CrossSections (@var{...})
## @deftypefnx {csg-toolkit} {[@var{CS_Geometry}, @var{SMoA}, @var{polyline}] =} visualize_CrossSections (@var{...})
##
## Plot cross sectional contours and their CSG properties for a given sample.
##
## @code{visualize_CrossSections} reads the respective @qcode{$geometry-$$.csv},
## @qcode{$inertia-$$.csv}, @qcode{$polyline2D-$$.csv}, and
## @qcode{$polyline3D-$$.csv} files available in the working directory, where
## @qcode{$$} is the @var{bone_id} char string for the required bone and
## @qcode{$} denotes the @var{mode} of bone analysis, and plots the 2D cross
## sectional polygons from proximal (top) to distal (bottom) along with certain
## information regarding cross sectional area, perimeter, and second moments of
## area.
##
## When called with a single input argument, @code{visualize_CrossSections}
## reads the files produced with the @code{longbone_Analysis} function, i.e. it
## reads the @qcode{Dgeometry-bone_id.csv}, @qcode{Dinertia-bone_id.csv},
## @qcode{Dpolyline2D-bone_id.csv}, and @qcode{Dpolyline3D-bone_id.csv} files
## associated with @var{bone_id}.  Optionally, if called with a second argument,
## @var{mode}, then the function reads the files generated by the respective
## function as shown below.
##
## @multitable @columnfractions 0.2 0.4 0.4
## @headitem @var{mode} @tab Function @tab CSV Files
## @item @qcode{"default"} @tab @code{longbone_Geometry}
## @tab @qcode{Dgeometry-bone_id.csv}
## @item @tab @tab @qcode{Dinertia-bone_id.csv}
## @item @tab @tab @qcode{Dpolyline2D-bone_id.csv}
## @item @qcode{"custom"} @tab @code{longbone_CustomGeometry}
## @tab @qcode{Cgeometry-bone_id.csv}
## @item @tab @tab @qcode{Cinertia-bone_id.csv}
## @item @tab @tab @qcode{Cpolyline2D-bone_id.csv}
## @item @qcode{"fragment"} @tab @code{longbone_FragmentGeometry}
## @tab @qcode{Fgeometry-bone_id.csv}
## @item @tab @tab @qcode{Finertia-bone_id.csv}
## @item @tab @tab @qcode{Fpolyline2D-bone_id.csv}
## @end multitable
##
## In default mode, @code{visualize_CrossSections} produces 5 plots with the
## cross sections at 20%, 35%, 50%, 65%, and 80% of the longbone's max distance,
## whereas in @qcode{"custom"} and @qcode{"fragment"} modes, it produces an
## arbitrary number of plots according to the cross sections contained in the
## associated files.  All four CSV files corresponding to @var{bone_id} must be
## present in the working directory.
##
## The centroid of each cross section is centered at origin and the x-axis of
## the plots represents the frontal axis of the bone from left to right side,
## whereas the y-axis is aligned to the sagital axis with the top pointing
## towards the front side (anterior). Both axes retain equal size so that the
## actual shape of the cross sectional area is preserved. However, each figure
## has a different scaling factor. Consequently, size may not be visually
## proportional among different figures, but the axes in each figure preserve
## the values of the actual size for the displayed cross section.
##
## If output arguments are defined, then @code{visualize_CrossSections} returns
## up to three structures with the following fields, containing the data
## retrieved from the CSV files.  The number of elements of each structure
## correspond to the number of cross sections generated by the respective
## @qcode{longbone_} function.
##
## @multitable @columnfractions .2 .2 .6
## @headitem Structure @tab Field @tab Data
## @item @var{CS_Geometry} @tab @qcode{CS} @tab The ratio of the cross section's
## distance from the proximal end to the bone's maximum length or the ordered
## index of the sectioning point for bone fragments.
## @item @tab @qcode{Area} @tab The cross sectional aera measured in
## @math{mm^2}.
## @item @tab @qcode{Perimeter} @tab The perimeter of the cross section
## measured in @math{mm}.
## @item @tab @qcode{Centroid} @tab The @var{x}, @var{y}, @var{z} coordinates of
## the cross sectional centroid.
## @item @tab @qcode{Section_n} @tab The @var{x}, @var{y}, @var{z} coordinates
## of the cross sectional plane's normal.
## @item @tab @qcode{Coronal_n} @tab The @var{x}, @var{y}, @var{z} coordinates
## of the normal of the bone's Coronal plane.
##
## @item @var{SMoA} @tab @qcode{Ix} @tab The 2nd moment of area with respect to
## the @var{x} axis, which is collinear with the intersection of the coronal
## plane and the sectioning plane, measured in @math{mm^4}.
## @item @tab @qcode{Iy} @tab The 2nd moment of area with respect to @var{y}
## axis, which is collinear with the intersection of the sagital plane and the
## sectioning plane, measured in @math{mm^4}.
## @item @tab @qcode{Ixy} @tab The product of the 2nd moment of area measured in
## @math{mm^4}.
## @item @tab @qcode{Imin} @tab The minimum 2nd moment of area measured in
## @math{mm^4}.
## @item @tab @qcode{Imax} @tab The maximum 2nd moment of area measured in
## @math{mm^4}.
## @item @tab @qcode{theta} @tab The angle of rotation of the principal axis
## of 2nd moment of area with respect to @var{x} axis, measured in degrees.
##
## @item @var{polyline} @tab @qcode{poly2D} @tab An @math{Nx2} matrix with the
## @var{x}, @var{y} coordinates of the cross section, ordered counter-clockwise,
## on the 2D local axes of the sectioning plane.
## @item @tab @qcode{poly3D} @tab An @math{Nx3} matrix with the @var{x},
## @var{y}, @var{z} coordinates of the cross section, ordered counter-clockwise,
## in the original 3D space of the bone's 3D model.
## @end multitable
##
## If @var{mode} is defined as @qcode{"fragment"}, then @qcode{Coronal_n} field
## is not available in @var{CS_Geometry} and the fields @qcode{Ixy}, @qcode{Iy},
## @qcode{theta} are missing from @var{SMoA}.
##
## @seealso{inspect_CSG, longbone_Analysis, longbone_CustomGeometry,
## longbone_FragmentGeometry}
## @end deftypefn

function [varargout] = visualize_CrossSections (bone_id, varargin)

  ## Check input
  if (nargin > 2)
    print_usage;
  endif

  if (! ischar (bone_id))
    error ("visualize_CrossSections: BONE_ID must be a string.");
  endif

  if (nargin == 1)
    mode = "default";
  else
    mode = varargin{1};
    if (! ischar (mode))
      error ("visualize_CrossSections: MODE must be a string.");
    endif
  endif

  ## Fix CSV files
  switch (mode)
    case "default"
      g_filename = strcat ("Dgeometry-", bone_id, ".csv");
      i_filename = strcat ("Dinertia-", bone_id, ".csv");
      p2_filename = strcat ("Dpolyline2D-", bone_id, ".csv");
      p3_filename = strcat ("Dpolyline3D-", bone_id, ".csv");
    case "custom"
      g_filename = strcat ("Cgeometry-", bone_id, ".csv");
      i_filename = strcat ("Cinertia-", bone_id, ".csv");
      p2_filename = strcat ("Cpolyline2D-", bone_id, ".csv");
      p3_filename = strcat ("Cpolyline3D-", bone_id, ".csv");
    case "fragment"
      g_filename = strcat ("Fgeometry-", bone_id, ".csv");
      i_filename = strcat ("Finertia-", bone_id, ".csv");
      p2_filename = strcat ("Fpolyline2D-", bone_id, ".csv");
      p3_filename = strcat ("Fpolyline3D-", bone_id, ".csv");
    otherwise
      error ("visualize_CrossSections: invalid MODE.");
  endswitch

  ## Read files if available
  filenames = readdir (pwd);
  if (sum (strcmp (filenames, g_filename)) == 1)
    geometry = csvread (filenames(strcmp (filenames, g_filename)){:});
  endif
  if (sum (strcmp (filenames, i_filename)) == 1)
    inertia = csvread (filenames(strcmp (filenames, i_filename)){:});
  endif
  if (sum (strcmp (filenames, p2_filename)) == 1)
    poly2 = csvread (filenames(strcmp (filenames, p2_filename)){:});
  endif
  if (sum (strcmp (filenames, p3_filename)) == 1)
    poly3 = csvread (filenames(strcmp (filenames, p3_filename)){:});
  endif

  ## Check if all files present
  if (! (exist ("geometry") == 1 && exist ("inertia") == 1 &&
         exist ("poly2") == 1 && exist ("poly3") == 1))
    error ("visualize_CrossSections: not all CSV files are present.");
  endif

  ## Switch MODE
  switch (mode)
    case "default"
      cs = {" 20%", " 35%", " 50%", " 65%", " 80%"};
      notF = true;
    case "custom"
      for i = 1: size (geometry, 1)
        cs{i} = sprintf(" %0.2d%%", geometry(i,1) * 100);
      endfor
      notF = true;
    case "fragment"
      for i = 1: size (geometry, 1)
        cs{i} = sprintf(" point %.0d", geometry(i,1));
      endfor
      notF = false;
  endswitch

  ## Store data from the CSV files to the corresponding structures
  for i = 1:length (cs)
    ## Geometry
    CS_Geometry(i).CS = geometry(i,1);
    CS_Geometry(i).Area = geometry(i,2);
    CS_Geometry(i).Perimeter = geometry(i,3);
    CS_Geometry(i).Centroid = geometry(i,[4:6]);
    CS_Geometry(i).Section_n = geometry(i,[7:9]);
    if (notF)
      CS_Geometry(i).Coronal_n = geometry(i,[10:12]);
      ## Inertia
      SMoA(i).Ix = inertia(i,2);
      SMoA(i).Iy = inertia(i,3);
      SMoA(i).Ixy = inertia(i,4);
      SMoA(i).Imin = inertia(i,5);
      SMoA(i).Imax = inertia(i,6);
      SMoA(i).theta = inertia(i,7);
    else
      SMoA(i).Ixy = inertia(i,2);
      SMoA(i).Imin = inertia(i,3);
      SMoA(i).Imax = inertia(i,4);
    endif
    ## Polyline2D
    poly_x = poly2(:,i*2-1);
    poly_y = poly2(:,i*2);
    ## Remove the trailing zeros from each column
    last_x = find (poly_x, 1, 'last');
    last_y = find (poly_y, 1, 'last');
    last_index = max ([last_x, last_y]);
    polyX = poly_x([2:last_index],:);
    polyY = poly_y([2:last_index],:);
    polyline(i).poly2D = [polyX, polyY];
    clear poly_x poly_y last_x last_y polyX polyY;
    ## Polyline3D
    poly_x = poly3(:,i*3-2);
    poly_y = poly3(:,i*3-1);
    poly_z = poly3(:,i*3);
    ## Remove the trailing zeros from each column
    last_x = find (poly_x, 1, 'last');
    last_y = find (poly_y, 1, 'last');
    last_z = find (poly_z, 1, 'last');
    last_index = max ([last_x, last_y, last_z]);
    polyX = poly_x([2:last_index],:);
    polyY = poly_y([2:last_index],:);
    polyZ = poly_z([2:last_index],:);
    polyline(i).poly3D = [polyX, polyY, polyZ];
    clear poly_x poly_y poly_z last_x last_y last_z polyX polyY polyZ;
  endfor

  ## Plot figures
  for i = 1:length (cs)
    figure (i, "name", bone_id, "numbertitle", "off");
    x = [polyline(i).poly2D(:,1); polyline(i).poly2D(1,1)];
    y = [polyline(i).poly2D(:,2); polyline(i).poly2D(1,2)];
    plot (x, y);
    axis ("image");
    title (strcat ("Cross section at ",cs{i}), 'FontSize', 16);
    xlabel ('Frontal axis (mm)','FontSize', 10);
    ylabel ('Sagital axis (mm)','FontSize', 10);
    grid ("on");
    if (notF)
      legend (["Perimeter = ", num2str(CS_Geometry(i).Perimeter,'%5.1f'), ...
               " mm", ...
               "\nArea = ", num2str(CS_Geometry(i).Area,'%5.1f'), " mm^2", ...
               "\nIx = ", num2str(SMoA(i).Ix,'%5.1f'), " mm^4", ...
               "\nIy = ", num2str(SMoA(i).Iy,'%5.1f'), " mm^4", ...
               "\nIxy = ", num2str(SMoA(i).Ixy,'%5.1f'), " mm^4", ...
               "\nImin = ", num2str(SMoA(i).Imin,'%5.1f'), " mm^4", ...
               "\nImax = ", num2str(SMoA(i).Imax,'%5.1f'), " mm^4", ...
               "\ntheta = ", num2str(SMoA(i).theta,'%5.1f'), "^o"], ...
              'FontSize', 14, 'box', "off", 'location', 'eastoutside');
    else
      legend (["Perimeter = ", num2str(CS_Geometry(i).Perimeter,'%5.1f'), ...
               " mm", ...
               "\nArea = ", num2str(CS_Geometry(i).Area,'%5.1f'), " mm^2", ...
               "\nIxy = ", num2str(SMoA(i).Ixy,'%5.1f'), " mm^4", ...
               "\nImin = ", num2str(SMoA(i).Imin,'%5.1f'), " mm^4", ...
               "\nImax = ", num2str(SMoA(i).Imax,'%5.1f'), " mm^4"], ...
              'FontSize', 14, 'box', "off", 'location', 'eastoutside');
    endif
    pos(i,:) = get (gcf, 'Position');
    pos(i,1) = pos(i,1) + (i - 1) * 150;
    set (gcf, 'Position', [pos(i,1), pos(i,2), pos(i,3), pos(i,4)]);
  endfor

  ## check if output arguments are defined and return the data structures
  if (nargout == 1)
    varargout{1} = CS_Geometry;
  elseif (nargout == 2)
    varargout{1} = CS_Geometry;
    varargout{2} = SMoA;
  elseif (nargout == 3)
    varargout{1} = CS_Geometry;
    varargout{2} = SMoA;
    varargout{3} = polyline;
  endif

endfunction
